var structVec=(()=>{var W=Object.defineProperty;var q=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var X=Object.prototype.hasOwnProperty;var G=(h,e)=>{for(var t in e)W(h,t,{get:e[t],enumerable:!0})},Z=(h,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of U(e))!X.call(h,s)&&s!==t&&W(h,s,{get:()=>e[s],enumerable:!(n=q(e,s))||n.enumerable});return h};var H=h=>Z(W({},"__esModule",{value:!0}),h);var ie={};G(ie,{Vec:()=>b,default:()=>se,validateStructDef:()=>M,vec:()=>k,vecCompile:()=>O});var I=Float64Array,V=SharedArrayBuffer,L=["char","num","bool"],b=class{constructor(e,t){try{this._memory=t||K(this.elementSize,e),this._length=this._memory[this._memory.length-1],this._capacity=this._memory[this._memory.length-2],this._cursor=new this.cursorDef(this)}catch(n){throw new Error(`[Vec::allocator] buffer memory failed to initialize. ${n}`)}}static isVec(e){return e instanceof this}static fromMemory(e){return new this(0,e)}static fromArray(e){let t=new this(e.length+15);return t.push(...e),t}static fromString(e){let t=JSON.parse(e);if(!Array.isArray(t))throw TypeError("inputted string was not a stringified vec");let n=new this(0),s=t[t.length-3];if(s!==n.elementSize)throw TypeError(`Inputted array does not match the encoding for this vec class. Size of element must be ${n.elementSize}, got "${s}" (type=${typeof s})`);let r=t[t.length-1],i=t[t.length-2];if(!Number.isInteger(r)||!Number.isInteger(i))throw TypeError("Inputted length or capacity of vec is not an integer.");n.reserve(i);let o=n._memory;for(let c=0;c<t.length-3;c+=1)o[c]=t[c];return n._length=r,n}get elementSize(){return 1}get def(){return{}}get cursorDef(){return class{constructor(){this.e={}}}}get cursor(){return this._cursor}get length(){return this._length}get capacity(){return this._capacity}get memory(){let e=this._memory;return e[e.length-2]=this._capacity,e[e.length-1]=this._length,e}set memory(e){this._capacity=e[e.length-2],this._length=e[e.length-1],this._memory=e}index(e){return this._cursor._viewingIndex=e*this.elementSize,this.cursor}at(e){let t=Math.abs(e);return this.index(e<0&&t!==0?this._length-t:t)}forEach(e){let t=this._cursor._viewingIndex,n=this._length;for(let s=0;s<n;s+=1){let r=this.index(s);e(r,s,this)}this._cursor._viewingIndex=t}map(e){let t=this._cursor._viewingIndex,n=[],s=this._length;for(let r=0;r<s;r+=1){let i=this.index(r);n.push(e(i,r,this))}return this._cursor._viewingIndex=t,n}mapv(e){let t=this._cursor._viewingIndex,n=new this.constructor(0,this.memory.slice()),s=n.length;for(let r=0;r<s;r+=1){let i=n.index(r),o=e(i,r,this);i.e=o}return _(n),this._cursor._viewingIndex=t,n}filter(e){let t=this._cursor._viewingIndex,n=this._length,s=this.elementSize,r=this.slice(),i=0;for(let o=0;o<n;o+=1){let c=this.index(o);if(e(c,o,this)){let l=o*s;r._memory.copyWithin(i*s,l,l+s),i+=1}}return this._cursor._viewingIndex=t,r._length=i,_(r),r}find(e){let t=this._cursor._viewingIndex,n=this._length;for(let s=0;s<n;s+=1){let r=this.index(s);if(e(r,s,this))return this._cursor._viewingIndex=t,this.index(s)}this._cursor._viewingIndex=t}findIndex(e){let t=this._cursor._viewingIndex,n=this._length;for(let s=0;s<n;s+=1){let r=this.index(s);if(e(r,s,this))return this._cursor._viewingIndex=t,s}return this._cursor._viewingIndex=t,-1}lastIndexOf(e){let t=this._cursor._viewingIndex,n=this._length;for(let s=n-1;s>-1;s-=1){let r=this.index(s);if(e(r,s,this))return this._cursor._viewingIndex=t,s}return this._cursor._viewingIndex=t,-1}reduce(e,t){if(t===void 0)throw TypeError("Reduce of vec with no initial value. Initial value argument is required.");let n=this._cursor._viewingIndex,s=t,r=this._length;for(let i=0;i<r;i+=1){let o=this.index(i);s=e(s,o,i,this)}return this._cursor._viewingIndex=n,s}reduceRight(e,t){if(t===void 0)throw TypeError("Reduce of vec with no initial value. Initial value argument is required.");let n=this._cursor._viewingIndex,s=t,r=this._length;for(let i=r-1;i>-1;i-=1){let o=this.index(i);s=e(s,o,i,this)}return this._cursor._viewingIndex=n,s}every(e){let t=this._cursor._viewingIndex,n=this._length;for(let s=0;s<n;s+=1){let r=this.index(s);if(!e(r,s,this))return this._cursor._viewingIndex=t,!1}return this._cursor._viewingIndex=t,!0}some(e){let t=this._cursor._viewingIndex,n=this._length;for(let s=0;s<n;s+=1){let r=this.index(s);if(e(r,s,this))return this._cursor._viewingIndex=t,!0}return this._cursor._viewingIndex=t,!1}[Symbol.iterator](){let e=-1,t=this._length;return{next:()=>({done:(e+=1)>=t,value:this.index(e).e})}}entries(){let e=-1,t=this._length;return{[Symbol.iterator]:()=>({next:()=>({done:(e+=1)>=t,value:[e,this.index(e).e]})})}}keys(){let e=-1,t=this._length;return{[Symbol.iterator]:()=>({next:()=>({done:(e+=1)>=t,value:e})})}}values(){let e=-1,t=this._length;return{[Symbol.iterator]:()=>({next:()=>({done:(e+=1)>=t,value:this.index(e).e})})}}slice(e=0,t){let n=this.elementSize,s=this._length,r=e<0?s+e:e;if(r<0||r>s-1)return new this.constructor;t=t||this._length;let i=t<0?s+t:t;if(i<0||i>s)return new this.constructor;let o=new this.constructor,c=i-r;if(c<0)return o;let l=this._memory.slice(),a=r*n,u=i*n;return l.copyWithin(0,a,u),o._length=c,o._memory=l,_(o),o}copyWithin(e,t=0,n){let s=this.elementSize,r=this._length,i=e<0?r+e:e;if(i<0||i>r-1)return this;let o=t<0?r+t:t;if(o<0||o>r-1)return this;n=n||r;let c=n<0?r+n:n;return c<0||c>r?this:(this._memory.copyWithin(i*s,o*s,c*s),this)}reserve(e){try{let t=this.elementSize,n=this._length,s=this._capacity;if(n+e<=s)return;let r=n+e,i=I.BYTES_PER_ELEMENT*t*r,o=16+i,c=new V(o),l=new I(c);return l.set(this._memory),this._memory=l,this._capacity=r,this}catch(t){throw console.error("Vec ::allocator: runtime failed to allocate more memory for vec. Aborting operation",t),t}}reverse(){let e=this.elementSize;if(this._length<2)return this;let n=0,s=this._length-1;this.reserve(1);let r=this._length*e;for(;n<s;){let i=n*e;this._memory.copyWithin(r,i,i+e);let o=s*e;this._memory.copyWithin(i,o,o+e),this._memory.copyWithin(o,r,r+e),n+=1,s-=1}return this}concat(...e){let t=this.elementSize,n=0,s=0;n+=this.length,s+=this.capacity;for(let o=0;o<e.length;o+=1){let c=e[o];n+=c.length,s+=c.capacity}let r=new this.constructor(s),i=0;r._memory.set(this._memory,i),i+=this.length*t;for(let o=0;o<e.length;o+=1){let c=e[o];r._memory.set(c._memory,i),i+=c.length*t}return r._length=n,_(r),r}pop(){if(this._length<1){_(this);return}let e=this.index(this._length-1).e;return this._length-=1,_(this),e}truncate(e){if(this._length<1)return _(this),0;let t=e>this._length?this._length:e;return this._length-=t,_(this),this._length}fill(e,t=0,n){let s=this.elementSize,r=this._capacity,i=this._length,o=t<0?i+t:t;o=o<0?0:o>i-1?i:o,n=n||r;let c=n<0?r+n:n;c=c<0?0:c>r?r:c;let l=c-o;if(l<1)return this;if(this.index(o).e=e,l<2)return this;let a=o*s,u=c*s,f=s,m=a+f,g=m;for(this._length=o;g<u;)this._memory.copyWithin(g,a,m),f+=f,m=a+f,g=m;return this._memory.copyWithin(g,a,m),this._length+=l,this}push(...e){let t=this.elementSize,n=this._length,s=this._capacity,r=n+e.length;if(r>s)try{let o=s*2,c=r>o?r+15:o,l=I.BYTES_PER_ELEMENT*t*c,a=16+l,u=new V(a),f=new I(u);f.set(this._memory),this._memory=f,this._capacity=c}catch(o){throw new Error(`[Vec::allocator] runtime failed to allocate more memory for vec. ${o}`)}let i=this._cursor._viewingIndex;for(let o=0;o<e.length;o+=1){let c=e[o];this.index(n).e=c,n+=1}return this._length=n,this._cursor._viewingIndex=i,n}splice(e,t,...n){let s=this.elementSize,r=this._length,i=e<0?r+e:e,o=n.length+15,c=new this.constructor(o);if(i<0||i>r-1)return c;let l=r-i;l=l<0?0:l,t=t===void 0?l:t,t=t<1?0:t,t=t>l?l:t;let a=0;if(t===n.length)for(let u=i;u<i+n.length;u+=1){let f=this.index(u);c.push(f.e);let m=n[a];f.e=m,a+=1}else if(t>n.length){let u=i+n.length;for(let p=i;p<u;p+=1)c.push(this.index(p).e),this.index(p).e=n[a],a+=1;let f=t-n.length;for(let p=u;p<u+f;p+=1){let T=this.index(p).e;c.push(T)}let m=(i+n.length)*s,g=(i+t)*s,y=this._length*s;this._memory.copyWithin(m,g,y),this._length-=f,_(this)}else{let u=n.length-t;this.reserve(u);let f=(i+u)*s,m=i*s;this._memory.copyWithin(f,m),this._length+=u;let g=i+t;for(let y=i;y<g;y+=1)c.push(this.index(y).e),this.index(y).e=n[a],a+=1;for(let y=g;y<i+n.length;y+=1)this.index(y).e=n[a],a+=1}return c}shift(){let e=this.elementSize,t=this._length;if(t<1){_(this);return}let n=this.index(0).e;if(this._length-=1,t<2)return _(this),n;let s=1*e,r=(t-1)*e+e;return this._memory.copyWithin(0,s,r),_(this),n}unshift(...e){let t=this.elementSize,n=this._length,s=n+e.length;if(this._length=s,n<1){for(let i=0;i<e.length;i+=1)this.index(i).e=e[i];return s}let r=e.length*t;this._memory.copyWithin(r,0);for(let i=0;i<e.length;i+=1)this.index(i).e=e[i];return s}shrinkTo(e=15){try{let t=this.elementSize,n=this._length,s=this._capacity,r=e<0?0:e,i=n+r;return i>=s?this:(this._memory=j(this._memory,t,i),this._capacity=i,this)}catch(t){throw new Error(`[Vec::allocator] runtime failed to deallocate memory for vec. ${t}`)}}sort(e){if(this._length<2)return this;let t=new this.cursorDef(this);this.reserve(1);let n=this.elementSize,s=this._length*n;if(this._length===2){if(e(t,this.index(1))!==0){let o=0*n;this._memory.copyWithin(s,o,o+n);let c=1*n;this._memory.copyWithin(o,c,c+n),this._memory.copyWithin(c,s,s+n)}return this}let r=!1;for(;!r;){r=!0;for(let i=0;i<this._length-1;i+=1){if(t._viewingIndex=i*n,e(t,this.index(i+1))===0)continue;r=!1;let c=i*n;this._memory.copyWithin(s,c,c+n);let l=(i+1)*n;this._memory.copyWithin(c,l,l+n),this._memory.copyWithin(l,s,s+n)}}return this}swap(e,t){this.reserve(1);let n=this.elementSize,s=this._length*n;e=e<0?this._length+e:e;let r=e*n;this._memory.copyWithin(s,r,r+n),t=t<0?this._length+t:t;let i=t*n;return this._memory.copyWithin(r,i,i+n),this._memory.copyWithin(i,s,s+n),this}toJSON(){let e="[",t=this.length*this.elementSize;for(let n=0;n<t;n+=1)e+=(this._memory[n]||0).toString()+",";return e+=`${this.elementSize},${this._capacity},${this._length}]`,e}};function K(h,e=15){let t=Math.abs(e),s=I.BYTES_PER_ELEMENT*h*t+16,r=new V(s),i=new Float64Array(r);return i[i.length-2]=t,i[i.length-1]=0,i}function j(h,e,t){let s=I.BYTES_PER_ELEMENT*e*t+16,r=new V(s),i=new I(r);for(let o=0;o<h.length;o+=1)i[o]=h[o];return i}function _(h){let e=h.elementSize,t=h.length;h.capacity-t<=50||(h._memory=j(h._memory,e,t+50),h._capacity=t+50)}var Q=/^[A-Za-z_\\$][A-Za-z0-9_\\$]*$/,S="[VecGenerator]";function C(h){return Q.test(h)}function ee(h){switch(h){case"num":case"bool":case"char":return!0;default:return!1}}function te(h){switch(h){case"self":case"e":case"_viewingIndex":case"ref":case"isNull":return!0;default:return!1}}var F=32;function A(h){if(typeof h!="object"||h===null||Array.isArray(h))throw SyntaxError(`${S} inputted invalid struct def. Expected object in the form of '{"field1": "num", "field2": "char", "field3": "bool"}' got ${JSON.stringify(h)}`);let e=Object.keys(h).map(c=>({field:c,type:h[c]}));if(e.length<1)throw SyntaxError(`${S} struct definition must have at least one key`);let t=0,n={elementSize:0,fieldNames:[],numberFields:[],booleanFields:[],charFields:[]},s=[],r=[],i=[];for(let c=0;c<e.length;c+=1){let{field:l,type:a}=e[c];if(typeof l!="string"||!C(l))throw SyntaxError(`${S} Bracket notation is disallowed, all structDef must be indexable by dot notation. Field "${l}" of struct requires indexing as "vec['${l}']" which is disallowed. Consider removing any hyphens.`);if(te(l))throw SyntaxError(`${S} field "${l}" is a reserved name.`);if(typeof a!="string")throw SyntaxError(`${S} field "${l}" is not a string, got "${typeof a}". Struct definition field values must be a string of ${L.join(", ")}`);if(!ee(a))throw SyntaxError(`${S} field "${l}" is not a valid type (got type "${a}"). Struct definition fields can only be of type of ${L.join(", ")}`);a==="num"?s.push(l):a==="bool"?r.push(l):a==="char"&&i.push(l)}s.sort();for(let c=0;c<s.length;c+=1){let l=s[c];n.fieldNames.push(l),n.numberFields.push({field:l,offset:t}),t+=1}i.sort();for(let c=0;c<i.length;c+=1){let l=i[c];n.fieldNames.push(l),n.charFields.push({field:l,offset:t}),t+=1}r.sort();let o=0;for(;o<r.length;){let c=r.length-o,l=c<F?c:F;for(let a=o;a<o+l;a+=1){let u=r[a];n.fieldNames.push(u),n.booleanFields.push({field:u,offset:t,byteOffset:a-o})}t+=1,o+=F}return n.elementSize=t,n}function ne(h){switch(h){case"false":case"true":case"null":case"await":case"static":case"public":case"protected":case"private":case"package":case"let":case"interface":case"implements":case"yield":case"with":case"while":case"void":case"var":case"typeof":case"try":case"throw":case"this":case"switch":case"super":case"return":case"new":case"instanceof":case"in":case"import":case"if":case"function":case"for":case"finally":case"extends":case"export":case"else":case"do":case"delete":case"default":case"debugger":case"continue":case"const":case"class":case"catch":case"case":case"break":return!0;default:return!1}}function D(h){if(typeof h!="object"||h===null||Array.isArray(h))throw TypeError(`input options must be of type "object", got type "${typeof h}"`);if(typeof h.pathToLib!="string"||!h.pathToLib)throw TypeError("option 'pathToLib' missing");if(typeof h.className!="string"||!C(h.className)||ne(h.className)||h.className.length<1)throw SyntaxError(`inputted class name is not a valid javascript class name, got "${h.className}"`);switch(h.exportSyntax){case"named":case"default":case"none":break;default:throw TypeError("invalid export Syntax option. exportSyntax must be either 'none', 'named', or 'default', got '"+h.exportSyntax+"''")}if(h.lang!=="js"&&h.lang!=="ts")throw TypeError(`option "bindings" must be either "js" or "ts". Got "${h.bindings}"`)}function B(h,e,{lang:t,pathToLib:n,className:s,exportSyntax:r,runtimeCompile:i}){let{elementSize:o,fieldNames:c,numberFields:l,booleanFields:a,charFields:u}=h,f=JSON.stringify(e),m=t==="ts",g=`<${f}>`,y=`"${n}"`,p=`import {Vec${m?", StructDef, Struct, CursorConstructor":""}} from ${y}`,T="CursorConstructor"+g,N=m?"(this.self as unknown as {_memory: Float64Array})._memory":"this.self._memory";return{className:s,def:`
${n!=="none"?p:""}
${m||i?"":`/**
 * @extends {Vec${g}}
 */`}
${r==="named"?"export ":""}class ${s} extends Vec${m?g:""} {
    ${m?"protected ":""}static Cursor = class Cursor {
        _viewingIndex = 0${m?`
		self: Vec`+g:""}
        constructor(self${m?": Vec"+g:""}) { this.self = self }
        ${l.map(({field:d,offset:x})=>{let $=x<1?"":" + "+x.toString(),v=`${N}[this._viewingIndex${$}]`,w=m?": number":"",z=`get ${d}()${w} { return ${v} }`,E=`set ${d}(newValue${w}) { ${v} = newValue }`;return`${z}; ${E};`}).join(`
	    `)}
        ${u.map(({field:d,offset:x})=>{let $=x<1?"":" + "+x.toString(),v=`${N}[this._viewingIndex${$}]`,w=m?": string":"",z=`get ${d}()${w} { return String.fromCodePoint(${v} || ${32}) }`,E=`set ${d}(newValue${w}) { ${v} = newValue.codePointAt(0) || ${32} }`;return`${z}; ${E};`}).join(`
	    `)}
        ${a.map(({field:d,offset:x,byteOffset:$})=>{let v=x<1?"":" + "+x.toString(),w=1<<$,z=~w,E=m?": boolean":"",P=m?"(Boolean(newValue) as unknown as number)":"Boolean(newValue)",R=`${N}[this._viewingIndex${v}]`,Y=`get ${d}()${E} { return Boolean(${R} & ${w}) }`,J=`set ${d}(newValue${E}) { ${R} &= ${z};${R} |= ${P}${$<1?"":" << "+$.toString()}}`;return`${Y}; ${J};`}).join(`
	    `)}
        set e({${c.map(d=>d).join(", ")}}${m?": Struct"+g:""}) { ${c.map(d=>"this."+d+" = "+d).join(";")}; }
        get e()${m?": Struct"+g:""} { return {${c.map(d=>d+": this."+d).join(", ")}} }        
    }${m?" as "+T:""}
    get elementSize()${m?": number":""} { return ${o} }
    get def()${m?": StructDef":""} { return ${f} }
    ${m?"protected ":""}get cursorDef()${m?": "+T:""} { return ${s}.Cursor }
}

${r==="default"?`export default {${s}}`:""}
`.trim()}}function M(h){try{return A(h),!0}catch(e){return!1}}function k(h){if(typeof SharedArrayBuffer=="undefined")throw new Error(`${S} sharedArrayBuffers are not supported in this environment and are required for vecs`);let e=A(h),{def:t,className:n}=B(e,h,{lang:"js",exportSyntax:"none",pathToLib:"none",className:"AnonymousVec",runtimeCompile:!0});return Function(`"use strict";return (Vec) => {
        ${t}
        return ${n}
    }`)()(b)}function O(h,e,t={}){let{lang:n="js",exportSyntax:s="none",className:r="AnonymousVec"}=t,i={lang:n,pathToLib:e,className:r,exportSyntax:s,runtimeCompile:!1};D(i);let o=A(h),{def:c}=B(o,h,i);return c}var se={vec:k,Vec:b,validateStructDef:M,vecCompile:O};return H(ie);})();
